
[5장 velog 링크](https://velog.io/@algorithm_cell/AI-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-5%EC%9E%A5.-%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81)


---

**프롬프트 엔지니어링**은 모델이 원하는 결과를 생성하도록 지시를 정교하게 다듬는 과정이고, 가장 쉬운 **모델 조정 기법**이다. 모델의 가중치를 변경하지 않고도, 모델의 응답을 조절할 수 있기 때문이다.

프롬프트를 작성하는 것은 쉬워보이지만 **효과적인 프롬프트**를 구성하는 것은 결코 쉽지 않은 과제이기 때문에 이번 장에서는 **효과적인 프롬프트 작성법**과 **프롬프트 공격에 애플리케이션을 방어하는 방법** 등에 대해 다뤄보려 한다.

# 1) 프롬프트 *prompt*

- 모델에게 특정 작업을 수행하도록 지시하는 것
 : 프롬프트는 **다음 요소들 중 하나 이상을 포함한다.**
	 
    - **작업 설명** : 모델이 수행해야할 일에 대한 설명과 출력형식 등을 포함한다.
    - **작업 수행 방식의 예시** 
    - **작업** :  모델이 수행해야할 일로, 응답할 질의나 요약할 내용 등을 포함한다.
   
  > ### 개체명 인식(NER)을 수행하는 간단한 프롬프트 예시
  >
  >**과제 설명**
  >
  >주어진 텍스트에서 모든 개체를 추출하세요.  
  >추출된 개체들의 **목록만** 쉼표로 구분해 출력하고,  
  >다른 내용은 포함하지 마세요.
  >
  >---
  >
  >**예시**
  >
  >텍스트 : 멋진 신세계는 올더스 헉슬리가 쓴 디스토피아 소설로, 1932년에 처음 출간되었다
  >
  >개체 : 멋진 신세계, 올더스 헉슬리
  >
  >---
  >
  >**과제**
  >
  >텍스트 : {개체를 추출하고자 하는 텍스트}
  > 
  >개체 :

- 이러한 프폼프트 엔지니어링은 모델이 강건할수록 적게 필요하다.


### 인컨텍스트 러닝 *In-Context Learning(ICL)*

- ICL은 LLM이 프롬프트로 제공된 문맥 정보나 몇 가지 예시만을 통해 새로운 작업을 이해하고 수행하는 능력이다.

- 프롬프트에 제공된 각 예시를 **shot**이라고 부르고, 모델에게 프롬프트에 제공한 예시를 통해 학습하도록 가르치는 방식을 **few-shot learning**이라고 한다.

	
    - 애플리케이션에 필요한 최적의 예시 수는 실험을 통해 알 수 있다.
    - 많은 예시를 보여줄수록 학습 효과는 좋아지겠지만, 프롬프트가 길어져 추론 비용이 증가한다.

### 프롬프트 종류

대부분의 모델 제공업체들은 잘 만들어진 **시스템 프롬프트**가 성능을 향상시킬 수 있다고 말한다.

**1) 시스템 프롬프트** *system prompt*
 

- 모델에 특정 역할, 성격, 제약 조건, 행동 규칙 등을 부여한다.

- AI 모델에게 전반적인 지침이나 역할을 부여하는 초기 설정으로, **작업에 대한 설명**을 제시하는 프롬프트이다.

**2) 사용자 프롬프트** *user prompt*

- 실제로 모델에게 전달되는 질문이나 요청으로, 사용자는 모델에게 원하는 정보 구체적으로 전달하여 정확한 응답을 얻을 수 있다.

> **예시**
>
> **1. 시스템 프롬프트**: 당신은 경험 많은 부동산 공인중개사다. 당신의 일은 각 공개 정보를 주의 깊게 읽고, 이 정보를 바탕으로 부동산 상태를 공정하게 평가하며, 구매자가 각 부동산의 위험과 기회를 이해하도록 돕는 것이다. 각 질의에 간결하고 전문적으로 응답하라.
>
> **2. 사용자 프롬프트**: 
> 컨텍스트: [disclosure.pdf] 
> 질의: 이 부동산에 관한 소음 민원이 있다면 요약해줘. 
> 응답:


 모델별로 **서로 다른 채팅 템플릿을 사용한다.** 따라서 템플릿 불일치 문제를 피하기 위해 따라야 할 몇 가지 좋은 방법을 소개한다. 
 
 - 파운데이션 모델에 대한 입력을 구성할 때, 입력이 모델의 채팅 템플릿을 정확히 따르는지 확인한다.
 
 - 프롬프트를 구성할 때 서드파티 도구를 사용한다면, 해당 도구가 올바른 채팅 템플릿을 사용하는지 확인한다.
 
 - 모델에 질의를 보내기 전에, 최종 프롬프트를 출력해 예상된 템플릿을 따르는지 다시 확인한다.


시스템 프롬프트가 성능을 성능을 사용자 프롬프트보다 향상 시킬 수 있는 이유는
**1. 시스템 프롬프트가 최종 프롬프트 맨 앞에 위치하기 때문에, 2. 오픈AI 논문에서 공유된 것처럼, 시스템 프롬프트에 더 주의를 기울이도록 사후 학습되었을 수 있기 때문이다.**


### context 길이와 효율성


**1. context 길이**

<p align="center">
  <img src="https://velog.velcdn.com/images/algorithm_cell/post/b80dc9e7-c5c3-42c5-9745-261fb2bfb90a/image.png" />
<p align="center">컨텍스트 길이는 계속 확장되고 있다.</p>

- 2M 컨텍스트 길이는 약 2,000개의 위키피디아 페이지와 파이토치 같은 복잡한 코드베이스를 담을 수 있다.


**2. context 효율성**

프롬프트의 모든 부분이 동일한 영향을 가지는 것은 아니다.
이러한 프롬프트 내 위치 효과를 평가하기 위해 **건초더미 속 바늘 테스트**가 사용된다. 

**건초더미 속 바늘 (NIAH) 테스트**
<p align="center">
  <img src="https://velog.velcdn.com/images/algorithm_cell/post/901092fa-dd1a-4840-a2d0-3300786df4f6/image.png" />
<p align="center">NIAH 프롬프트 예시</p>

- 이 방법은 무작위 정보를 프롬프트의 여러 위치에 삽입한 뒤, 모델이 이를 얼마나 잘 찾아내는지를 측정한다.

-  실제 질의와 응답을 사용할 수도 있다.

<p align="center">
  <img src="https://velog.velcdn.com/images/algorithm_cell/post/06ae21d8-b046-4f73-9cce-7f29f711fbee/image.png" />
<p align="center">낮은 위치일수록 입력 컨텍스트의 시작 부분에 가깝다는 뜻</p>

- 연구 결과, 모든 테스트된 모델에서 정보가 **프롬프트의 시작이나 끝에 가까울수록 더 잘 탐지되는 경향**이 확인되었다.

---

# 2) 프롬프트 작성 가이드

다양한 모델에서 효과가 검증되었고, 유용하게 사용할 수 있는 일반적인 기법들에 대해 다뤄보려고 한다.
일반적인 방법 이외에도, 그 모델의 최적화된 가이드를 참고하는 것이 좋다.


### Ⓐ 명확하고 명시적인 지시 작성하기

AI와 소통하는 것은 사람과 소통하는 것과 같기 때문에 명확하게 소통할수록 더 도움이 돈다.

**1. 모델이 해야 할 일을 모호함 없이 설명하기**

**2. 모델에게 특정 페르소나 부여하기**

- 페르소나는 모델에게 특정 역할이나 성격을 부여해 그 관점에서 응답하도록 돕는다.
![](https://velog.velcdn.com/images/algorithm_cell/post/c9481eaf-8e68-46ae-82a4-409d7e685f0d/image.png)

**3. 예시 제공하기**

-  예시를 통해 모델이 어떻게 응답해야할 지에 대한 모호함을 줄일 수 있다. 
- 적은 토큰을 사용하는 예시 형식을 사용하는 것 역시 좋다. 

**4. 출력 형식 지정하기**

![](https://velog.velcdn.com/images/algorithm_cell/post/d86f7b71-fa9a-4497-9489-acdd7f64b3aa/image.png)

- 입력의 끝나는 지점을 명확히 표시하는 마커가 없으면, 모델은 구조화된 출력을 생성하는 대신 기존 입력에 계속 내용을 이어 붙일 수 있다.


### Ⓑ 충분한 컨텍스트 제공하기

만약 모델에게 어떤 논문에 관한 질의에 응답하도록 하고 싶다면, 그 논문을 컨텍스트에 포함시키는 것이 모델의 응답을 향상시킬 가능성이 높다.

- 컨텍스트 구성 도구에는 RAG 파이프라인과 같은  데이터 검색과 웹 검색이 포함된다.

### Ⓒ 복잡한 작업을 단순한 하위 작업으로 나누기

여러 단계가 필요한 큰 작업은 하위 작업으로 나누는 것이 좋다.

프롬프트 분해는 **성능 향상** 뿐 아니라, **모니터링, 디버깅, 병렬화, 노력 절감** 등의 효과가 있다. 

### Ⓓ 모델에게 생각할 시간 주기

**CoT *chain of thought*** : 모델에게 단계별로 생각하도록 명시적으로 요청해서 문제를 더 체계적으로 접근을 유도하는 것을 의미한다. 

![](https://velog.velcdn.com/images/algorithm_cell/post/8307449a-8628-459a-9268-70dd60e1d573/image.png)

- 생각의 사슬은 MAWPS(수학 단어 문제 해결), SVAMP(시퀀스 번형 분석, 맵, 계통 발생학) .. 에서 성능을 향상시켰다.

어떤 방식의 CoT가 효과적인지는 애플리케이션에 따라 달라진다.
**자기 비평** 방식을 통해서도 자신의 출력을 검토하게 해 문제에 대해 비판적으로 생각하도록 유도할 수 있다.


### Ⓔ 프롬프트 반복하며 개선하기

프롬프트 엔지니어링은 한 번에 완성되는 작업이 아니라 반복적인 개선 과정이 필요하다. 모델은 질문을 그대로 받아들이기보다 맥락에 따라 다양한 방식으로 해석하므로, 원하는 답이 나오지 않으면 프롬프트를 수정하고, 보완해 나가야 한다.

또한 모델마다 강점과 선호하는 지시 위치가 다르기 때문에, 여러 프롬프트를 실험하고 다양한 모델에 동일한 프롬프트를 적용해 응답 차이를 비교하는 것이 중요하다. 이를 통해 사용 중인 모델의 특성을 더 깊이 이해할 수 있다.

### Ⓕ 프롬프트 엔지니어링 도구 평가하기

프롬프트는 무한히 만들 수 있지만, 이를 직접 설계하고 최적화하는 과정은 많은 시간과 노력이 필요하기 때문에 자동화하는 도구들이 등장했다. 

대표적으로 OpenPrompt와 DSPy가 있다.

이러한 도구를 올바르게 사용하면 시스템 성능을 크게 향상시킬 수 있지만, 내부 동작을 이해하지 못하면 오히려 문제가 발생할 수 있다.

**1.** 프롬프트 엔지니어링 도구는 사용자 인지 없이 대량의 모델 API 호출을 생성할 수 있어 비용과 사용 한도를 빠르게 초과할 위험이 있다.

**2.** 도구 자체의 결함이나 버그, 템플릿 오류, 내부 토큰 연결 실수 등으로 인해 잘못된 프롬프트가 생성될 가능성도 존재하며, 일부 도구는 경고 없이 프롬프트 템플릿이나 기본 프롬프트를 변경할 수도 있다.


<p align="center">
  <img src="https://velog.velcdn.com/images/algorithm_cell/post/08abd7e2-46a7-494b-95ef-df2785d03cf7/image.png" />
<p align="center">프롬프트에 오타가 포함된 예시</p>

따라서 처음에는 도구 없이 직접 프롬프트를 작성하며 단순성을 유지하는 것이 권장되며, 도구를 사용할 경우에도 생성된 프롬프트가 의미 있는지, API 호출이 얼마나 발생하는지 지속적으로 검토해야 한다. 


### Ⓖ 프롬프트 정리 및 버전 관리하기

프롬프트를 코드와 분리해서 관리하는 것이 좋다.

이렇게 할 때의 장점은, 

**1. 재사용성** : 여러 애플리케이션이 동일한 프롬프트를 재사용할 수 있다.
**2. 테스트** : 코드와 프롬프트를 별도로 테스트할 수 있다.
**3. 가독성**
**4. 협업**

효과적으로 프롬프트를 관리하는 방법은, 

각 프롬프트에 메타 데이터를 추가해 어떤 용도로 만들어진 것인지 쉽게 파악할 수 있게 한다. 프롬프트를 .prompt파일 형식으로 저장하여 관리한다.

- 프롬프트 템플릿이 포함할 정보
   - 모델 엔드포인트 url
   - 온도나, top=p같은 샘플링 파라미터
   - 입력 스키마
   - 예상되는 출력 스키마
    
- 프롬프트의 버전을 명확히 구분해 관리하는 프롬프트 카탈로그를 구성하면, 효과적으로 관리할 수 있다.

---

# 3) 방어적 프롬프팅

애플리케이션을 안전하게 유지하려면 먼저 시스템이 어떤 공격에 취약한지 파악해야한다. 이때 **Advbench, PromptRobust 같은 벤치마크**를 활용하면 시스템이 적대적 **공격에 얼마나 강건**한지 평가할 수 있다.

**보안 점검을 자동화 도구**에는 Azure/PyRIT, leondz/garak, greshake/llm-security, CHATS=labpersuasive_jailbreaker 등이 있고, 이 도구들은 주로 알려진 공격 패턴을 템플릿으로 가지고  모델을 자동으로 테스트한다. 


이러한 점검과 평가를 통해 시스템의 취약 지점을 파악했다면, 다음 단계는 이를 어떻게 방어할 것인가에 대해 설계해야한다.

방어 전략은 **모델 수준, 프롬프트 수준, 시스템 수준**으로 나눌 수 있다.




### 모델 수준 방어

프롬프트 공격이 가능한 근본 원인은 모델이 **시스템 지시와 악의적 지시를 구분하지 못하기 때문이다.**
이를 위해 모델이 **시스템 프롬프트를 우선적으로 따르도록 학습**하면 많은 공격을 효과적으로 차단할 수 있다.

**지시 계층**

![](https://velog.velcdn.com/images/algorithm_cell/post/bac3b95b-3f4a-4c94-8f92-d8df438c82ae/image.png)

- 지시가 충돌하는 경우에는 더 높은 계층의 지시를 따라야한다.
- 이런 계층 구조를 통해 다양한 간접 프롬프트 주입 공격을 효과적으로 방어할 수 있다.
- 오픈AI는 이러한 지시 계층을 반영한 데이터셋으로 모델을 파인튜닝하여, 안전성은 향상시키면서도 기본 성능 저하는 최소화했고, 공격에 대한 강건성은 최대 63%까지 개선했다.

### 프롬프트 수준 방어

**1.** 모델이 하지 말아야 할 행동을 명확히 지시함으로써 공격에 더 강한 프롬프트를 만들 수 있다.
예를들어, 이메일 주소나 전화번호 같은 **민감 정보 제공 금지나 특정 정보 외의 출력 제한**처럼 제약을 지시에 넣는 것은 도움이 된다. 

**2.** 모델이 해야할 일을 반복해서 명시한다.
![](https://velog.velcdn.com/images/algorithm_cell/post/889412e6-b1e9-4282-8a2f-84edf654132f/image.png)

모델에게 해야 할 일을 상기시키는데 도움이 되지만, 처리해야할 시스템 프롬프트 토큰이 두 배로 늘어나 비용과 시간 지연이 발생한다.



### 시스템 수준 방어

시스템은 사용자를 안전하게 보호하도록 설계해야한다. 보호하는 방식은 다음과 같다.

**1. 격리** 
: 생성 코드가 실행되는 경우에는 사용자 기기와 분리된 가상 머신에서만 실행해 악성 코드의 피해를 제한한다. 

**2. 승인 과정**
: 또한 데이터베이스 변경처럼 시스템에 큰 영향을 주는 명령은 명시적 승인을 거치도록 규칙을 둔다.

**3. 범위 제한**
: 애플리케이션이 다루지 않는 주제는 범위를 명확히 정의하고, 특정 키워드나 패턴을 통해 부적절한 요청을 사전에 차단한다.

**4. AI 활용**
: 대화 전체를 분석해 사용자 의도를 파악하고, 부적절한 의도가 있는 요청은 차단하거나 운영자에게 전달한다.
: **이상 탐지 알고리즘**으로 비정상적 프롬프트를 식별할 수 있다.


보안은 입력과 출력 모두에 적용되어야 한다.
입력 단계에서는 차단 키워드, 공격 패턴 탐지 모델을 활용하고, 출력 단계에서는 PII 등 유해 정보 포함 여부를 검사한다.
